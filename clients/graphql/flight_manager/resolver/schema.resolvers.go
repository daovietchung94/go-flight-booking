package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.31

import (
	"context"
	"fmt"
	"go-training/clients/graphql/flight_manager/generated"
	"go-training/clients/graphql/flight_manager/model"
	"go-training/pb"
	"strings"
	"time"
)

// CreateFlight is the resolver for the createFlight field.
func (r *mutationResolver) CreateFlight(ctx context.Context, input model.CreateFlightRequest) (*model.Flight, error) {
	pReq := &pb.CreateFlightRequest{
		PlaneNumber: input.PlaneNumber,
		FromCity:    input.FromCity,
		ToCity:      input.ToCity,
		DepTime: &pb.Date{
			Year:  int32(input.DepTime.Year()),
			Month: int32(input.DepTime.Month()),
			Day:   int32(input.DepTime.Day()),
		},
		ArrTime: &pb.Date{
			Year:  int32(input.ArrTime.Year()),
			Month: int32(input.ArrTime.Month()),
			Day:   int32(input.ArrTime.Day()),
		},
	}

	pRes, err := r.MyFlightClient.CreateFlight(ctx, pReq)
	if err != nil {
		panic(fmt.Errorf(err.Error()))
	}

	dto := &model.Flight{
		ID:          pRes.Id,
		PlaneNumber: pRes.PlaneNumber,
		NumOfSeats:  int(pRes.NumOfSeats),
		FromCity:    pRes.FromCity,
		ToCity:      pRes.ToCity,
		DepTime:     time.Date(int(pRes.DepTime.Year), time.Month(pRes.DepTime.Month), int(pRes.DepTime.Day), 0, 0, 0, 0, time.Local),
		ArrTime:     time.Date(int(pRes.ArrTime.Year), time.Month(pRes.ArrTime.Month), int(pRes.ArrTime.Day), 0, 0, 0, 0, time.Local),
		IsLanded:    pRes.IsLanded,
	}

	return dto, nil
}

// GetFlights is the resolver for the getFlights field.
func (r *queryResolver) GetFlights(ctx context.Context, input model.GetFlightsRequest) (*model.GetFlightsResponse, error) {
	pReq := &pb.GetFlightsRequest{
		Page:   int32(input.Page),
		Limit:  int32(input.Limit),
		Sort:   input.Sort,
		Filter: &pb.FlightFilter{},
	}

	if input.Filter != nil {
		if input.Filter.Time != nil {
			pReq.Filter.Time = &pb.Date{
				Year:  int32(input.Filter.Time.Year()),
				Month: int32(input.Filter.Time.Month()),
				Day:   int32(input.Filter.Time.Day()),
			}
		}
		if input.Filter.City != nil {
			if city := strings.TrimSpace(*input.Filter.City); city != "" {
				pReq.Filter.City = city
			}
		}
	}

	pRes, err := r.MyFlightClient.GetFlights(ctx, pReq)
	if err != nil {
		panic(fmt.Errorf(err.Error()))
	}

	flights := make([]*model.Flight, len(pRes.Rows))
	for i, v := range pRes.Rows {
		flights[i] = &model.Flight{
			ID:          v.Id,
			PlaneNumber: v.PlaneNumber,
			NumOfSeats:  int(v.NumOfSeats),
			FromCity:    v.FromCity,
			ToCity:      v.ToCity,
			DepTime:     time.Date(int(v.DepTime.Year), time.Month(v.DepTime.Month), int(v.DepTime.Day), 0, 0, 0, 0, time.Local),
			ArrTime:     time.Date(int(v.ArrTime.Year), time.Month(v.ArrTime.Month), int(v.ArrTime.Day), 0, 0, 0, 0, time.Local),
			IsLanded:    v.IsLanded,
		}
	}

	dto := &model.GetFlightsResponse{
		Page:       int(pRes.GetPage()),
		Limit:      int(pRes.GetLimit()),
		Sort:       pRes.GetSort(),
		TotalRows:  int(pRes.GetTotalRows()),
		TotalPages: int(pRes.GetTotalPages()),
		Rows:       flights,
	}

	return dto, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
